#ifndef _IOU_HPP
#define _IOU_HPP

#include "Loss.hpp"
#include <cmath>

namespace loss
{
    /** Basic interface for a loss function
     * 
     * @tparam T Scalar type for evaluating the loss function
     */
    template<typename T>
    class IoU : public Loss<T>
    {
        public:
        /** Evaluates the intersection-over-union loss gradient
         * 
         * Calculates the intersection over union loss. Each index in the 
         * actual value is expected to be a 0 or 1 value.
         * 
         * Intersection is estimated as the sum of the element-wise 
         * product of the predicted and actual values. 
         * The union is estimated as the sum of the predicted and actual 
         * values minus the intersection.
         * 
         * @param predicted Data generated by a model
         * @param actual Ground truth data
         * @param loss Optional reference to variable that net loss will be stored in
        */       
        Eigen::Vector<T, Eigen::Dynamic> grad(Eigen::Vector<T, Eigen::Dynamic>& predicted, Eigen::Vector<T, Eigen::Dynamic>& actual, T& loss) { return _grad(predicted, actual, loss); };
        Eigen::Tensor<T, 3> grad(Eigen::Tensor<T, 3>& predicted, Eigen::Tensor<T, 3>& actual, T& loss) { return _grad(predicted, actual, loss); };

        template<typename X>
        static X _grad(X& predicted, X& actual, T& loss)
        {
            auto a = Loss<T>::make_array(actual);
            auto p = Loss<T>::make_array(predicted);
            T i = (a * p).sum();
            T u = a.sum() + p.sum() - i;            
            loss = i / u;
            return actual.unaryExpr([i,u](T x){ return (x*u + (T(1)-x)*i) / std::pow(u, T(2)); });
        }
    };
}

#endif