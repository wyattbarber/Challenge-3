#ifndef _MODEL_HPP
#define _MODEL_HPP

#include <Eigen/Dense>
#include <unsupported/Eigen/CXX11/Tensor>
#include <utility>
#include <memory>

#ifndef NOPYTHON
#include <pybind11/pybind11.h>
namespace py = pybind11;
#endif

namespace neuralnet
{
    /** Abstract class defining basic behavior for neural network components
     *
     * All specific types of layer should inherit from this base class.
     */
    template <class ModelType>
    class Model
    {
    public:
        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
                
        /**
         * Runs one forward pass through the model.
         *
         * @param input input vector
         * @return output of this layer
         */
        template<typename X>
        auto forward(X&& input){return static_cast<ModelType*>(this)->forward(std::forward<X>(input));}

        /**
         * Propagates error over this layer, and back over input layers
         *
         * Error gradients for this pass (or the information needed to
         * calculate them later) should be calculated and stored in this
         * method, but the model parameters should not be updated.
         *
         * Gradients calculated over subsequent calls to this method
         * should be accumulated.
         *
         * @param error error gradient of layer following this one
         * @return error of the layer preceding this one
         */
        template<typename X>
        auto backward(X&& error){return static_cast<ModelType*>(this)->backward(std::forward<X>(error));}

        /**
         * Updates parameters of this layer
         *
         * Error gradients accumulated over previous calls to backwards are
         * used to update this models weights and biases.
         *
         * If an optimizer has been defined, it is called here
         * to augment the gradients before applying the update.
         *
         * @param rate learning rate
         */
        void update(double rate){static_cast<ModelType*>(this)->update(rate);}    

#ifndef NOPYTHON
        /** Gets the models current state for pickling.
         * 
         * Should record all the models relevant state info (constructor args
         * and trainable parameters) so that a model could be reconstructed from 
         * the exported info. 
         * 
         * Only info needed to reconstruct the models behavior in forward data
         * processing is needed, intermediate data stored only between forward and 
         * backward passes in training should not be returned.
         * 
         * @return py::tuple containing all necessary state info for the model.
        */
        static py::tuple getstate(const Model<ModelType>& obj){ return ModelType::getstate(obj); }

        /** Sets the models state from pickled data.
         * 
         * Takes a py::tuple generated by a past call to this classes `getstate` 
         * method and creates a new instance of the model with an identical state.
         * 
         * @param data py::tuple produced by `getstate`
         */
        static Model<ModelType> setstate(py::tuple data){ return ModelType::setstate(data); }
#endif
    };


    /** Abstract class defining basic behavior for linked encoder type components
     *
     */
    template <class ModelType>
    class Encoder : Model<ModelType>
    {
        public:

        /** Generate a latent embedding for one input sample
         *
         * @param input input vector
         * @return latent space embedding
         */
        template<typename X>
        auto encode(X&& input){return static_cast<ModelType*>(this)->encode(std::forward<X>(input));}

        /** Decode a latent embedding
         *
         * @param latent embedding vector
         * @return decoded data
         */
        template<typename X>
        auto decode(X&& embed){return static_cast<ModelType*>(this)->decode(std::forward<X>(embed));}

        /** Perform backward pass over the encoder portion
         *
         * @param error error gradient of the embedding
         * @return propagated error gradient
         */
        template<typename X>
        auto backward_encode(X&& error){return static_cast<ModelType*>(this)->backward_encode(std::forward<X>(error));}

        /** Perform backward pass over the decoder portion
         *
         * @param error error gradient of the output
         * @return propagated error gradient
         */
        template<typename X>
        auto backward_decode(X&& error){return static_cast<ModelType*>(this)->backward_decode(std::forward<X>(error));}

    };
}
#endif
